import {
  Commitment,
  Connection,
  Keypair,
  PublicKey,
  PublicKeyInitData,
  Transaction,
} from '@solana/web3.js';
import {
  SignTransaction,
  modifySignTransaction,
  TransactionSignatureAndResponse,
  PreparedTransactions,
  TransactionWithIndex,
  sendAndConfirmTransactionsWithRetry,
} from './utils';
import { addComputeBudget } from './computeBudget';
import {
  createPostVaaInstruction,
  createVerifySignaturesInstructions,
  derivePostedVaaKey,
  getSignatureSetData,
  pendingSignatureVerificationTxs,
} from './wormhole';
import { isBytes, ParsedVaa, parseVaa, SignedVaa } from '../../../vaa/wormhole';

/**
 * @category Solana
 */
export async function postVaaWithRetry(
  connection: Connection,
  signTransaction: SignTransaction,
  wormholeProgramId: PublicKeyInitData,
  payer: PublicKeyInitData,
  vaa: Buffer,
  maxRetries?: number,
  commitment?: Commitment,
): Promise<TransactionSignatureAndResponse[]> {
  let parsedVaa: ParsedVaa;
  try {
    // Check if the VAA has already been posted
    parsedVaa = parseVaa(vaa);
    const postedVaaAddress = derivePostedVaaKey(
      wormholeProgramId,
      parsedVaa.hash,
    );
    const postedVaa = await connection.getAccountInfo(postedVaaAddress);
    console.log('postedVaaAddress', postedVaaAddress, postedVaa);
    if (postedVaa !== null) {
      return [];
    }
  } catch (e) {
    console.error('Failed to check if VAA has already been posted:', e);
  }
  const set = localStorage.getItem('signatureSet')?.split(',');
  const signatureSet =
    /*Keypair.generate();*/
    Keypair.fromSecretKey(new Uint8Array(set as any));

  console.log('signatureSet', signatureSet);
  const { unsignedTransactions, signers } =
    await createPostSignedVaaTransactions(
      connection,
      wormholeProgramId,
      payer,
      vaa,
      signatureSet,
      commitment,
    );
  const postVaaTransaction = unsignedTransactions.pop();
  if (!postVaaTransaction) throw new Error('No postVaaTransaction');
  postVaaTransaction.transaction.feePayer = new PublicKey(payer);

  // Returns the txs that are NOT present on the blockchain
  const transactionsNotPresent = await pendingSignatureVerificationTxs(
    unsignedTransactions,
    connection,
    wormholeProgramId,
    signatureSet,
    commitment,
  );

  console.log(
    'unsignedTransactions & transactionsNotPresent & postVaaTransaction',
    unsignedTransactions,
    transactionsNotPresent,
    postVaaTransaction,
  );

  for (const unsignedTransaction of transactionsNotPresent) {
    unsignedTransaction.transaction.feePayer = new PublicKey(payer);
    await addComputeBudget(
      connection,
      unsignedTransaction.transaction,
      [],
      0.75,
      1,
      true,
    );
  }

  let responses: TransactionSignatureAndResponse[] = [];
  if (!!transactionsNotPresent.length) {
    responses = await sendAndConfirmTransactionsWithRetry(
      connection,
      modifySignTransaction(signTransaction, ...signers),
      payer.toString(),
      transactionsNotPresent.map((tx) => tx.transaction),
      { maxRetries, commitment },
    );
    // if (responses.errors && responses.errors?.length > 0)
    //   printError(responses.errors);
  }

  const signatureSetData1 = await getSignatureSetData(
    connection,
    signatureSet?.publicKey,
    commitment,
  );
  console.log('signatureSetData1', signatureSetData1);

  //While the signature_set is used to create the final instruction, it doesn't need to sign it.
  await addComputeBudget(
    connection,
    postVaaTransaction.transaction,
    [],
    0.75,
    1,
    true,
  );
  responses.push(
    ...(await sendAndConfirmTransactionsWithRetry(
      connection,
      signTransaction,
      payer.toString(),
      [postVaaTransaction.transaction],
      { maxRetries, commitment },
    )),
  );

  const signatureSetData = await getSignatureSetData(
    connection,
    signatureSet?.publicKey,
    commitment,
  );
  console.log('signatureSetData', signatureSetData);

  // if (postVaaResponse.errors && postVaaResponse.errors?.length > 0)
  //   printError(postVaaResponse.errors);

  return responses;
}

/**
 * @category Solana
 *
 * Send transactions for `verify_signatures` and `post_vaa` instructions.
 *
 * Using a signed VAA, execute transactions generated by {@link verifySignatures} and
 * {@link postVaa}. At most 4 transactions are sent (up to 3 from signature verification
 * and 1 to post VAA data to an account).
 *
 * @param {Connection} connection - Solana web3 connection
 * @param {PublicKeyInitData} wormholeProgramId - wormhole program address
 * @param {web3.Keypair} payer - transaction signer address
 * @param {Buffer} signedVaa - bytes of signed VAA
 * @param {Commitment} [options] - Solana commitment
 *
 */
export async function createPostSignedVaaTransactions(
  connection: Connection,
  wormholeProgramId: PublicKeyInitData,
  payer: PublicKeyInitData,
  vaa: SignedVaa | ParsedVaa,
  signatureSet: Keypair,
  commitment?: Commitment,
): Promise<PreparedTransactions> {
  const parsed = isBytes(vaa) ? parseVaa(vaa) : vaa;

  const verifySignaturesInstructions = await createVerifySignaturesInstructions(
    connection,
    wormholeProgramId,
    payer,
    parsed,
    signatureSet.publicKey,
    commitment,
  );

  const unsignedTransactions: TransactionWithIndex[] = [];
  for (let i = 0; i < verifySignaturesInstructions.length; i++) {
    const tx = new Transaction();
    tx.add(...verifySignaturesInstructions[i].instructions);

    unsignedTransactions.push({
      transaction: tx,
      index: i,
      signatureIndexes: verifySignaturesInstructions[i].signatureIndexes,
    });
  }

  const postVaaTx = new Transaction();
  postVaaTx.add(
    createPostVaaInstruction(
      connection,
      wormholeProgramId,
      payer,
      parsed,
      signatureSet.publicKey,
    ),
  );

  unsignedTransactions.push({
    transaction: postVaaTx,
    index: verifySignaturesInstructions.length,
    signatureIndexes: [],
  });
  return {
    unsignedTransactions,
    signers: [signatureSet],
  };
}

// function printError(errors: any[]) {
//   throw new Error(
//     'Error posting VAA to Solana \n' +
//       errors.map((error) => error.toString()).join('\n'),
//   );
// }
